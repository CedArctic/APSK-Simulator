#
#   APSK Simulator
#   Author: CedArctic, Eva
#   Usage: Simulates a dual ring APSK
#

import random, csv, os, time, numpy, bitarray, math, gc, matplotlib.pyplot as plt
from bidict import bidict

class Symbol:

    # Length variable for the bit length per symbol (bits = log2(number_of_symbols))
    symbol_length = None

    # Original Symbol - the symbol as generated by the source, and its vector on the constellation
    original_symbol = None
    original_symbol_vector = None

    # Identified Symbol - the symbol as identified by the MLD Detector and its vector as received by the receiver
    # (received vector = original vector + additive white gaussian noise)
    identified_symbol = None
    received_symbol_vector = None

    # Symbol constructor
    def __init__(self, symbol_length, constellation, noise):
        self.symbol_length = symbol_length
        self.generate_bits(constellation)
        self.add_awgn(noise, constellation)
        self.mld(constellation)

    # Symbol destructor
    def __del__(self):
        self.symbol_length = None
        self.original_symbol = None
        self.original_symbol_vector = None
        self.identified_symbol = None
        self.received_symbol_vector = None
        gc.collect()

    # Generates a set of random bits for this symbol and identifies the symbol from the mapping table
    # of the provided constellation
    def generate_bits(self, constellation):

        # Initialize bits to an empty bit array and then populate it
        bits = bitarray.bitarray()

        for i in range(0, self.symbol_length) :
            bits.append(random.getrandbits(1))

        # Get symbol according to bitarray from mapping table
        self.original_symbol = constellation.bit_mapping_table.inverse[bits.to01()]
        self.original_symbol_vector = constellation.vector_mapping_table[self.original_symbol]


    # AWGN Generator - Generate an Additive White Gaussian Noise sample using a Noise object and add it to the original
    # symbol vector to create the received symbol vector
    def add_awgn(self, noise, constellation):
        self.received_symbol_vector = self.original_symbol_vector + complex(float(noise.generate_awgn()), float(noise.generate_awgn()))

    # Identify symbol by comparing received vector with the vectors of the constellation symbols (euclidean distance)
    def mld(self, constellation):
        min_dist = math.sqrt((constellation.symbols[0].original_symbol_vector.real - self.received_symbol_vector.real) ** 2
                             + (constellation.symbols[0].original_symbol_vector.imag - self.received_symbol_vector.imag)** 2)
        min_symbol = 0
        for i in range(0, constellation.ring_symbols_number * 2 ):
            cur_dist = math.sqrt((constellation.symbols[i].original_symbol_vector.real - self.received_symbol_vector.real) ** 2
                                 + (constellation.symbols[i].original_symbol_vector.imag - self.received_symbol_vector.imag) ** 2)
            if cur_dist < min_dist:
                min_dist = cur_dist
                min_symbol = i
        self.identified_symbol = 's' + str(min_symbol)

    # Check if identified symbol matches original symbol
    def symbol_check(self):
        if self.original_symbol == self.identified_symbol:
            return True
        return False

    # If symbol_check returns false, check individual bits for errors and return number of bit errors according to
    # provided constellation and its mapping table
    def bits_check(self, constellation):

        # If symbols match => 0 bits errors
        if self.symbol_check() == True:
            return 0

        # If symbols don't match, compare the bitarrays
        bit_errors = 0
        for i in range(0, self.symbol_length):
            if constellation.bit_mapping_table[self.original_symbol][i] != constellation.bit_mapping_table[self.identified_symbol][i]:
                bit_errors += 1
        return bit_errors


# Symbol class for constallation constant symbols
class Constellation_Symbol(Symbol):

    # Constellation Symbol constructor
    def __init__(self, symbol_length, bits, original_symbol_vector, original_symbol):
        self.symbol_length = symbol_length
        self.bits = bits
        self.original_symbol_vector = original_symbol_vector
        self.original_symbol = original_symbol


# APSK Constellation class
class Constellation:

    # Symbols per ring (an M-M APSK has M symbols per ring)
    ring_symbols_number = None

    # Inner and outer ring radii
    ri = None
    ro = None

    # B is the ratio of ri/ro
    b = None

    # Constellation symbols - an array containing symbol objects for the constellation
    symbols = None

    # Constellation Symbol Length
    symbol_length = None

    # Bidirectional symbol to bit Mapping Table - used to map bit arrays to symbols and their vectors and vice versa
    bit_mapping_table = bidict()

    # Bidirectional symbol to vector Mapping Table - used to map bit arrays to symbols and their vectors and vice versa
    vector_mapping_table = bidict()

    # Constellation Power
    power = None

    # Average Symbol Power
    symbol_power = None

    # Offset Angle - The angle between two consecutive symbols, an inner and an outer ring one (in degrees)
    angle = None

    # Constellation Constructor
    def __init__(self, ring_symbols_number, ri, ro):

        # Get symbols number on each ring
        self.ring_symbols_number = ring_symbols_number

        # Calculate symbol length based on symbol number
        self.symbol_length = int(math.log2(2 * self.ring_symbols_number))

        # Get inner ring radius
        self.ri = ri

        # Get outer ring radius
        self.ro = ro

        # Calculate b
        self.b = self.ri / self.ro

        # Calculate offset angle in degrees
        self.angle = 360 / (2*self.ring_symbols_number)

        # Calculate average symbol power
        self.symbol_power = (self.ri**2 + self.ro**2) / 2

        # Calculate constellation power
        self.power = self.ring_symbols_number * 2 * self.symbol_power

        # Create constellation symbols
        # Initialize symbols list
        self.symbols = [None] * (self.ring_symbols_number * 2)
        for i in range(0, 2 * self.ring_symbols_number):

            # If i is even, place symbol on the inner ring, else place it on the outer
            if i % 2 == 0 :
                x = self.ri * math.cos(i * self.angle * (math.pi / 180))
                y = self.ri * math.sin(i * self.angle * (math.pi / 180))
            else:
                x = self.ro * math.cos(i * self.angle * (math.pi / 180))
                y = self.ro * math.sin(i * self.angle * (math.pi / 180))

            # Create symbol vector and name
            original_symbol_vector = complex(x,y)
            original_symbol = 's' + str(i)

            # Create constellation symbol bitarray, add leading 0s if needed
            bits = bin(i)[2:]
            if self.symbol_length > len(bits) :
                for j in range(0,self.symbol_length - len(bits)):
                    bits = '0' + bits

            # Create mapping table entry (key: original_symbol, val: bits)
            self.bit_mapping_table.put(original_symbol, bits)

            # Create mapping table entry (key: original_symbol, val: bits)
            self.vector_mapping_table.put(original_symbol, original_symbol_vector)

            # Create Constellation Symbol
            self.symbols[i] = Constellation_Symbol(self.symbol_length, bits, original_symbol_vector, original_symbol)

    def __del__(self):
        for i in range (0, int(self.ring_symbols_number * 2)):
            del self.bit_mapping_table['s'+ str(i)]
            del self.vector_mapping_table['s'+str(i)]
        self.ring_symbols_number = None
        self.ri = None
        self.ro = None
        self.b = None
        self.symbols = None
        self.symbol_length = None
        self.power = None
        self.symbol_power = None
        self.angle = None
        gc.collect()


    def plot_constellation(self):
        # Plot constellation
        for i in range(0, (self.ring_symbols_number * 2)):
            plt.plot(self.symbols[i].original_symbol_vector.real,
                     self.symbols[i].original_symbol_vector.imag, 'ro-')
        circle1 = plt.Circle((0, 0), self.ri, color='r', fill=False)
        circle2 = plt.Circle((0, 0), self.ro, color='b', fill=False)
        plt.gcf().gca().add_artist(circle1)
        plt.gcf().gca().add_artist(circle2)
        plt.show()

